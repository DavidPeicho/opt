#version 450

struct Ray {
  vec3 origin;
  vec3 direction;
  vec2 padding_0;
};

struct Vertex {
  vec4 position;
  vec4 normal;
  vec4 tangent;
  vec2 uv;
  vec2 padding_0;
};

struct BVHNode
{
  vec4 min;
  vec4 max;
};

struct Instance {
  mat4x4 modelToWorld;
  uint bvhDepth;
  uint bvhStartIndex;
  uint materialIndex;
  uint padding_0;
};

struct Material {
  vec4 color;
};

struct Intersection {
  vec2 coords;
  uint faceIndex;
  uint padding_0;
};

layout (set = 0, binding = 0, std430) readonly buffer RayBuffer {
  Ray ray[];
};

layout (set = 0, binding = 1, std140) readonly buffer InstanceBuffer {
  Instance instances[];
};

layout (set = 0, binding = 2, std430) readonly buffer NodeBuffer {
  BVHNode nodes[];
};

layout (set = 0, binding = 3, std430) readonly buffer VertexBuffer {
  Vertex vertices[];
};

layout(set = 0, binding = 4, std140) writeonly buffer IntersectionBuffer {
  Intersection results[];
};

layout(set = 0, binding = 5) uniform bvhData {
  uint nbInstances;
} bvh;

bool
rayHitAABB(vec3 p0, vec3 p1, struct Ray r)
{
  // TODO: use view here to inverse ray dir
  vec3 invRayDir = r.dir;

  vec3 t0 = (p0 - r.origin) * invRaydir;
  vec3 t1 = (p1 - r.origin) * invRaydir;
  vec3 tmin = min(t0,t1), tmax = max(t0,t1);

  return max_component(tmin) <= min_component(tmax);
}

void main() {
  // Performs intersection.

  Ray r = rays[gl_GlobalInvocationID.x];

  uint instanceIdx = 0;
  while (instanceIdx < nbInstances)
  {
    Instance instance = instances[instanceIdx];

    uint nbNodes = instance.bvhDepth == 0 ? 1 : pow(2, instance.bvhDepth) + 1;

    uint boxIdx = instance.bvhStartIndex;
    uint maxIdx = boxIdx + nbNodes;
    while (boxIdx < maxIdx)
    {
      BVHNode node = nodes[boxIdx]
      if (rayHitAABB(node.min, node.max, r))
      {
        
      }
      boxIdx++;
    }

    instanceIdx++;
  }

  // Loop through instances BVH.
  // Find triangle in BVH.
  // Sort.
}
