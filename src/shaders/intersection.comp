#version 450

struct Ray {
  vec3 origin;
  vec3 direction;
  vec2 padding_0;
};

struct Vertex {
  vec4 position;
  vec4 normal;
  vec4 tangent;
  vec2 uv;
  vec2 padding_0;
};

struct BVHNode
{
  vec4 min;
  vec4 max;
};

struct Instance {
  mat4x4 modelToWorld;
  uint bvhDepth;
  uint bvhStartIndex;
  uint materialIndex;
  uint padding_0;
};

struct Material {
  vec4 color;
};

struct Intersection {
  vec2 coords;
  float distance;
  uint faceIndex;
};

layout (set = 0, binding = 0, std430) readonly buffer RayBuffer {
  Ray ray[];
};

layout (set = 0, binding = 1, std140) readonly buffer InstanceBuffer {
  Instance instances[];
};

layout (set = 0, binding = 2, std430) readonly buffer NodeBuffer {
  BVHNode nodes[];
};

layout (set = 0, binding = 3, std430) readonly buffer VertexBuffer {
  Vertex vertices[];
};

layout(set = 0, binding = 4, std140) writeonly buffer IntersectionBuffer {
  Intersection results[];
};

layout(set = 0, binding = 5) uniform bvhData {
  uint nbInstances;
} bvh;

bool
rayHitAABB(vec3 p0, vec3 p1, struct Ray r)
{
  return true;
}

void main() {
  // Performs intersection.

  Ray r = rays[gl_GlobalInvocationID.x];

  uint instanceIdx = 0;
  while (instanceIdx < nbInstances)
  {
    Instance instance = instances[instanceIdx];

    uint nbNodes = instance.bvhDepth == 0 ? 1 : pow(2, instance.bvhDepth) + 1;

    uint boxIdx = instance.bvhStartIndex;
    uint maxIdx = boxIdx + nbNodes;

    if (!rayHitAABB(node.min, node.max, r)) {
      results.distance = -1.0;
      return;
    }

    uint depth = 1;
    uint sibling = 0;
    while (depth <= instance.bvhDepth)
    {
      uint leftNodeIndex = boxIdx + (pow(2, depth) - 1 + sibling);
      BVHNode leftNode = nodes[leftNodeIndex]
      BVHNode rightNode = nodes[idx + 1]
      // Left child
      if (rayHitAABB(node.min, node.max, r))
      {
        depth += 1;
      }
      // Right child

    }

    instanceIdx++;
  }

  // Loop through instances BVH.
  // Find triangle in BVH.
  // Sort.
}
